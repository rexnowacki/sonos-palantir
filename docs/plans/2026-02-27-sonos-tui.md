# Sonos TUI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement the two-process Sonos TUI described in `sonos_project.md` — a Python FastAPI daemon wrapping `soco`, and a Rust Ratatui terminal UI that talks to it.

**Architecture:** Phase 1 builds and verifies the Python daemon against a real speaker ("cthulhu") before touching Rust. The daemon exposes a JSON REST API on `localhost:9271`. The Rust TUI is a thin client that renders daemon responses and sends commands back.

**Tech Stack:** Python 3.11+, FastAPI, soco, uvicorn, pyyaml, pytest, httpx / Rust, ratatui 0.29, crossterm 0.28, tokio 1, reqwest 0.12, serde

---

## Phase 1: Python Daemon

---

### Task 1: Scaffold daemon directory structure

**Files:**
- Create: `daemon/pyproject.toml`
- Create: `daemon/sonosd/__init__.py`
- Create: `daemon/sonosd/models.py`

**Step 1: Create the package directory**

```bash
mkdir -p daemon/sonosd
```

**Step 2: Create `daemon/pyproject.toml`**

```toml
[project]
name = "sonosd"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "soco>=0.30",
    "fastapi>=0.110",
    "uvicorn>=0.29",
    "pyyaml>=6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0",
    "httpx>=0.27",
]

[project.scripts]
sonosd = "sonosd.server:main"

[build-system]
requires = ["setuptools>=68"]
build-backend = "setuptools.backends.legacy:build"
```

**Step 3: Create `daemon/sonosd/__init__.py`**

```python
```
(empty file)

**Step 4: Create `daemon/sonosd/models.py`**

```python
# Pydantic response models (request models live in server.py)
from pydantic import BaseModel
from typing import Optional


class TrackInfo(BaseModel):
    title: str
    artist: str
    album: str
    duration: int
    position: int
    art_uri: str


class SpeakerInfo(BaseModel):
    name: str
    alias: Optional[str]
    ip: str
    volume: int
    muted: bool
    state: str
    group_coordinator: Optional[str]
    track: Optional[TrackInfo]
```

**Step 5: Set up venv and install**

```bash
cd daemon
python -m venv .venv
source .venv/bin/activate
pip install -e ".[dev]"
```

Expected: installs soco, fastapi, uvicorn, pyyaml, pytest, httpx with no errors.

**Step 6: Commit**

```bash
cd ..
git init
git add daemon/
git commit -m "feat: scaffold daemon package structure"
```

---

### Task 2: Create config.yaml

**Files:**
- Create: `daemon/config.yaml`

**Step 1: Create `daemon/config.yaml`**

```yaml
# Playlist aliases — map short names to Sonos Favorites
playlists:
  altwave: "Alt Wave"

# Speaker aliases — map short names to device names
speakers:
  cthulhu: "cthulhu"

# Defaults
default_speaker: cthulhu
default_volume: 25

# Server
host: "127.0.0.1"
port: 9271
```

**Step 2: Commit**

```bash
git add daemon/config.yaml
git commit -m "feat: add config.yaml with cthulhu speaker and Alt Wave playlist"
```

---

### Task 3: Implement `_parse_duration` utility and tests

**Files:**
- Create: `daemon/sonosd/sonos.py` (partial — utility function only)
- Create: `daemon/tests/__init__.py`
- Create: `daemon/tests/test_sonos.py`

**Step 1: Create `daemon/tests/__init__.py`**

```python
```
(empty file)

**Step 2: Write the failing test**

Create `daemon/tests/test_sonos.py`:

```python
from sonosd.sonos import _parse_duration


def test_parse_duration_full():
    assert _parse_duration("0:02:43") == 163


def test_parse_duration_hours():
    assert _parse_duration("1:00:00") == 3600


def test_parse_duration_zero():
    assert _parse_duration("0:00:00") == 0


def test_parse_duration_invalid_returns_zero():
    assert _parse_duration("") == 0
```

**Step 3: Run to confirm failure**

```bash
cd daemon
source .venv/bin/activate
pytest tests/test_sonos.py -v
```

Expected: `ImportError: cannot import name '_parse_duration' from 'sonosd.sonos'`

**Step 4: Create `daemon/sonosd/sonos.py` with just the utility**

```python
import soco
from typing import Optional


def _parse_duration(time_str: str) -> int:
    """Parse 'H:MM:SS' to total seconds."""
    parts = time_str.split(":")
    if len(parts) == 3:
        try:
            return int(parts[0]) * 3600 + int(parts[1]) * 60 + int(parts[2])
        except ValueError:
            return 0
    return 0
```

**Step 5: Run tests — expect pass**

```bash
pytest tests/test_sonos.py -v
```

Expected: 4 PASSED

**Step 6: Commit**

```bash
git add daemon/sonosd/sonos.py daemon/tests/
git commit -m "feat: add _parse_duration utility with tests"
```

---

### Task 4: Implement `SonosManager` and alias resolution tests

**Files:**
- Modify: `daemon/sonosd/sonos.py`
- Modify: `daemon/tests/test_sonos.py`

**Step 1: Add alias resolution tests**

Append to `daemon/tests/test_sonos.py`:

```python
from unittest.mock import MagicMock, patch


def _make_manager(config=None):
    """Build a SonosManager with mocked soco.discover."""
    if config is None:
        config = {
            "speakers": {"cthulhu": "cthulhu"},
            "playlists": {"altwave": "Alt Wave"},
        }

    mock_speaker = MagicMock()
    mock_speaker.player_name = "cthulhu"
    mock_speaker.ip_address = "192.168.1.99"
    mock_speaker.volume = 25
    mock_speaker.mute = False

    with patch("soco.discover", return_value={mock_speaker}):
        from sonosd.sonos import SonosManager
        manager = SonosManager(config)

    return manager, mock_speaker


def test_get_speaker_by_alias():
    manager, mock_speaker = _make_manager()
    result = manager.get_speaker("cthulhu")
    assert result is mock_speaker


def test_get_speaker_unknown_raises():
    manager, _ = _make_manager()
    import pytest
    with pytest.raises(KeyError):
        manager.get_speaker("nonexistent")


def test_get_all_speakers_returns_dict():
    manager, mock_speaker = _make_manager()
    all_speakers = manager.get_all_speakers()
    assert "cthulhu" in all_speakers
```

**Step 2: Run to confirm failure**

```bash
pytest tests/test_sonos.py::test_get_speaker_by_alias -v
```

Expected: `ImportError` or `AttributeError` — `SonosManager` not yet defined

**Step 3: Implement `SonosManager` in `daemon/sonosd/sonos.py`**

Replace the full file content:

```python
import soco
from typing import Optional


class SonosManager:
    """Manages speaker discovery and provides control methods."""

    def __init__(self, config: dict):
        self.config = config
        self._speakers: dict[str, soco.SoCo] = {}
        self._alias_map: dict[str, str] = config.get("speakers", {})
        self._reverse_alias: dict[str, str] = {v: k for k, v in self._alias_map.items()}
        self._playlist_map: dict[str, str] = config.get("playlists", {})
        self.refresh()

    def refresh(self) -> None:
        """Re-discover speakers on the network."""
        discovered = soco.discover(timeout=5)
        if discovered:
            self._speakers = {sp.player_name: sp for sp in discovered}

    def get_speaker(self, name_or_alias: str) -> soco.SoCo:
        """Resolve alias or name to a SoCo instance."""
        real_name = self._alias_map.get(name_or_alias, name_or_alias)
        if real_name in self._speakers:
            return self._speakers[real_name]
        raise KeyError(f"Speaker not found: {name_or_alias}")

    def get_all_speakers(self) -> dict[str, soco.SoCo]:
        return self._speakers

    def get_speaker_info(self, speaker: soco.SoCo) -> dict:
        """Build the full status dict for a speaker."""
        info = speaker.get_current_transport_info()
        track_info = speaker.get_current_track_info()

        track = None
        if track_info.get("title"):
            track = {
                "title": track_info.get("title", ""),
                "artist": track_info.get("artist", ""),
                "album": track_info.get("album", ""),
                "duration": _parse_duration(track_info.get("duration", "0:00:00")),
                "position": _parse_duration(track_info.get("position", "0:00:00")),
                "art_uri": track_info.get("album_art", ""),
            }

        coordinator = speaker.group.coordinator.player_name if speaker.group else None

        return {
            "name": speaker.player_name,
            "alias": self._reverse_alias.get(speaker.player_name),
            "ip": speaker.ip_address,
            "volume": speaker.volume,
            "muted": speaker.mute,
            "state": info.get("current_transport_state", "UNKNOWN"),
            "group_coordinator": coordinator,
            "track": track,
        }

    def play_favorite(self, speaker: soco.SoCo, favorite_name: str) -> None:
        """Play a Sonos Favorite by exact name or alias."""
        resolved = self._playlist_map.get(favorite_name, favorite_name)

        favorites = speaker.music_library.get_sonos_favorites()
        match = None
        for fav in favorites:
            if fav.title.lower() == resolved.lower():
                match = fav
                break

        if not match:
            available = [f.title for f in favorites]
            raise KeyError(
                f"Favorite '{resolved}' not found. Available: {available}"
            )

        uri = match.reference.get_uri()
        meta = match.resource_meta_data
        speaker.play_uri(uri, meta)

    def group_speakers(self, names_or_aliases: list[str]) -> soco.SoCo:
        """Group speakers. First becomes coordinator."""
        if names_or_aliases == ["all"]:
            speakers = list(self._speakers.values())
        else:
            speakers = [self.get_speaker(n) for n in names_or_aliases]

        coordinator = speakers[0]
        for sp in speakers[1:]:
            sp.join(coordinator)
        return coordinator

    def ungroup(self, name_or_alias: str | None = None) -> None:
        """Ungroup a specific speaker, or all."""
        if name_or_alias is None or name_or_alias == "all":
            for sp in self._speakers.values():
                sp.unjoin()
        else:
            self.get_speaker(name_or_alias).unjoin()


def _parse_duration(time_str: str) -> int:
    """Parse 'H:MM:SS' to total seconds."""
    parts = time_str.split(":")
    if len(parts) == 3:
        try:
            return int(parts[0]) * 3600 + int(parts[1]) * 60 + int(parts[2])
        except ValueError:
            return 0
    return 0
```

**Step 4: Run all sonos tests**

```bash
pytest tests/test_sonos.py -v
```

Expected: 7 PASSED

**Step 5: Commit**

```bash
git add daemon/sonosd/sonos.py daemon/tests/test_sonos.py
git commit -m "feat: implement SonosManager with alias resolution"
```

---

### Task 5: Implement FastAPI server and endpoint tests

**Files:**
- Create: `daemon/sonosd/server.py`
- Create: `daemon/tests/test_server.py`

**Step 1: Write the failing tests**

Create `daemon/tests/test_server.py`:

```python
from unittest.mock import MagicMock, patch
from fastapi.testclient import TestClient


def _make_client():
    """Build a TestClient with a fully mocked SonosManager."""
    mock_speaker = MagicMock()
    mock_speaker.player_name = "cthulhu"
    mock_speaker.ip_address = "192.168.1.99"
    mock_speaker.volume = 25
    mock_speaker.mute = False
    mock_speaker.group = None

    transport = {"current_transport_state": "PLAYING"}
    track = {
        "title": "Alt Wave Track",
        "artist": "Some Artist",
        "album": "Some Album",
        "duration": "0:03:00",
        "position": "0:01:00",
        "album_art": "",
    }
    mock_speaker.get_current_transport_info.return_value = transport
    mock_speaker.get_current_track_info.return_value = track

    mock_manager = MagicMock()
    mock_manager.get_all_speakers.return_value = {"cthulhu": mock_speaker}
    mock_manager.get_speaker_info.return_value = {
        "name": "cthulhu",
        "alias": "cthulhu",
        "ip": "192.168.1.99",
        "volume": 25,
        "muted": False,
        "state": "PLAYING",
        "group_coordinator": None,
        "track": {
            "title": "Alt Wave Track",
            "artist": "Some Artist",
            "album": "Some Album",
            "duration": 180,
            "position": 60,
            "art_uri": "",
        },
    }
    mock_manager._playlist_map = {"altwave": "Alt Wave"}
    mock_manager.get_speaker.return_value = mock_speaker

    import sonosd.server as server_module
    server_module.manager = mock_manager

    from sonosd.server import app
    return TestClient(app), mock_manager, mock_speaker


def test_get_speakers_returns_list():
    client, _, _ = _make_client()
    resp = client.get("/speakers")
    assert resp.status_code == 200
    data = resp.json()
    assert "speakers" in data
    assert data["speakers"][0]["name"] == "cthulhu"


def test_get_playlists():
    client, _, _ = _make_client()
    resp = client.get("/playlists")
    assert resp.status_code == 200
    assert resp.json()["playlists"]["altwave"] == "Alt Wave"


def test_play_returns_200():
    client, mock_manager, mock_speaker = _make_client()
    resp = client.post("/play", json={"speaker": "cthulhu", "playlist": "altwave"})
    assert resp.status_code == 200
    assert resp.json()["status"] == "playing"


def test_play_unknown_speaker_returns_404():
    client, mock_manager, _ = _make_client()
    mock_manager.get_speaker.side_effect = KeyError("Speaker not found: ghost")
    resp = client.post("/play", json={"speaker": "ghost", "playlist": "altwave"})
    assert resp.status_code == 404


def test_volume_clamps_to_100():
    client, mock_manager, mock_speaker = _make_client()
    resp = client.post("/volume", json={"speaker": "cthulhu", "volume": 150})
    assert resp.status_code == 200
    assert resp.json()["volume"] == 100


def test_pause_returns_200():
    client, _, _ = _make_client()
    resp = client.post("/pause", json={"speaker": "cthulhu"})
    assert resp.status_code == 200


def test_next_track_returns_200():
    client, _, _ = _make_client()
    resp = client.post("/next", json={"speaker": "cthulhu"})
    assert resp.status_code == 200
```

**Step 2: Run to confirm failure**

```bash
pytest tests/test_server.py -v
```

Expected: `ImportError: cannot import name 'app' from 'sonosd.server'`

**Step 3: Create `daemon/sonosd/server.py`**

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import uvicorn
import yaml
from pathlib import Path
from .sonos import SonosManager

app = FastAPI(title="sonosd")
manager: SonosManager = None


class PlayRequest(BaseModel):
    speaker: str
    playlist: str


class SpeakerRequest(BaseModel):
    speaker: str = "all"


class VolumeRequest(BaseModel):
    speaker: str
    volume: int


class GroupRequest(BaseModel):
    speakers: list[str]


@app.on_event("startup")
def startup():
    global manager
    config_path = Path(__file__).parent.parent / "config.yaml"
    with open(config_path) as f:
        config = yaml.safe_load(f)
    manager = SonosManager(config)


@app.get("/speakers")
def get_speakers():
    manager.refresh()
    speakers = []
    for name, sp in manager.get_all_speakers().items():
        try:
            speakers.append(manager.get_speaker_info(sp))
        except Exception:
            speakers.append({"name": name, "error": "unreachable"})
    return {"speakers": speakers}


@app.get("/favorites")
def get_favorites():
    speakers = list(manager.get_all_speakers().values())
    if not speakers:
        raise HTTPException(404, "No speakers found")
    favs = speakers[0].music_library.get_sonos_favorites()
    return {"favorites": [{"title": f.title} for f in favs]}


@app.get("/playlists")
def get_playlists():
    return {"playlists": manager._playlist_map}


@app.post("/play")
def play(req: PlayRequest):
    try:
        if req.speaker == "all":
            speaker = manager.group_speakers(["all"])
        else:
            speaker = manager.get_speaker(req.speaker)
        manager.play_favorite(speaker, req.playlist)
        return {"status": "playing", "speaker": speaker.player_name, "playlist": req.playlist}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/pause")
def pause(req: SpeakerRequest):
    try:
        if req.speaker == "all":
            for sp in manager.get_all_speakers().values():
                sp.pause()
        else:
            manager.get_speaker(req.speaker).pause()
        return {"status": "paused"}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/resume")
def resume(req: SpeakerRequest):
    try:
        if req.speaker == "all":
            for sp in manager.get_all_speakers().values():
                sp.play()
        else:
            manager.get_speaker(req.speaker).play()
        return {"status": "resumed"}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/stop")
def stop(req: SpeakerRequest):
    try:
        if req.speaker == "all":
            for sp in manager.get_all_speakers().values():
                sp.stop()
        else:
            manager.get_speaker(req.speaker).stop()
        return {"status": "stopped"}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/volume")
def set_volume(req: VolumeRequest):
    try:
        vol = max(0, min(100, req.volume))
        if req.speaker == "all":
            for sp in manager.get_all_speakers().values():
                sp.volume = vol
        else:
            manager.get_speaker(req.speaker).volume = vol
        return {"status": "ok", "volume": vol}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/group")
def group(req: GroupRequest):
    try:
        coordinator = manager.group_speakers(req.speakers)
        return {"status": "grouped", "coordinator": coordinator.player_name}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/ungroup")
def ungroup(req: SpeakerRequest):
    manager.ungroup(req.speaker)
    return {"status": "ungrouped"}


@app.post("/next")
def next_track(req: SpeakerRequest):
    try:
        manager.get_speaker(req.speaker).next()
        return {"status": "ok"}
    except KeyError as e:
        raise HTTPException(404, str(e))


@app.post("/previous")
def prev_track(req: SpeakerRequest):
    try:
        manager.get_speaker(req.speaker).previous()
        return {"status": "ok"}
    except KeyError as e:
        raise HTTPException(404, str(e))


def main():
    config_path = Path(__file__).parent.parent / "config.yaml"
    with open(config_path) as f:
        config = yaml.safe_load(f)
    host = config.get("host", "127.0.0.1")
    port = config.get("port", 9271)
    uvicorn.run(app, host=host, port=port)
```

**Step 4: Run all tests**

```bash
pytest tests/ -v
```

Expected: all PASSED (7 from test_sonos.py + 7 from test_server.py = 14 total)

**Step 5: Commit**

```bash
git add daemon/sonosd/server.py daemon/tests/test_server.py
git commit -m "feat: implement FastAPI server with endpoint tests"
```

---

### Task 6: Smoke test against real speaker

**Prerequisites:** Sonos speaker "cthulhu" must be on the local network.

**Step 1: Start the daemon**

```bash
cd daemon
source .venv/bin/activate
sonosd
```

Expected output:
```
INFO:     Uvicorn running on http://127.0.0.1:9271 (Press CTRL+C to quit)
```

(soco.discover may take a few seconds on startup)

**Step 2: In a second terminal, verify speakers endpoint**

```bash
curl -s http://localhost:9271/speakers | python -m json.tool
```

Expected: JSON with cthulhu's name, volume, and current state.

**Step 3: Verify playlists endpoint**

```bash
curl -s http://localhost:9271/playlists | python -m json.tool
```

Expected:
```json
{
  "playlists": {
    "altwave": "Alt Wave"
  }
}
```

**Step 4: Test play (will actually play on the speaker)**

```bash
curl -s -X POST http://localhost:9271/play \
  -H 'Content-Type: application/json' \
  -d '{"speaker": "cthulhu", "playlist": "altwave"}' | python -m json.tool
```

Expected:
```json
{
  "status": "playing",
  "speaker": "cthulhu",
  "playlist": "altwave"
}
```

**Step 5: Test pause**

```bash
curl -s -X POST http://localhost:9271/pause \
  -H 'Content-Type: application/json' \
  -d '{"speaker": "cthulhu"}' | python -m json.tool
```

**Step 6: Stop daemon (Ctrl+C), commit if any fixes were needed**

```bash
git add -p
git commit -m "fix: <describe any fixes from smoke test>"
```

---

## Phase 2: Rust TUI

---

### Task 7: Scaffold Rust TUI

**Files:**
- Create: `tui/Cargo.toml`
- Create: `tui/src/main.rs` (stub)

**Step 1: Create `tui/Cargo.toml`**

```toml
[package]
name = "sonos-tui"
version = "0.1.0"
edition = "2021"

[dependencies]
ratatui = "0.29"
crossterm = "0.28"
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
anyhow = "1"
```

**Step 2: Create `tui/src/main.rs` stub**

```rust
fn main() {
    println!("sonos-tui");
}
```

**Step 3: Verify it compiles**

```bash
cd tui
cargo build
```

Expected: compiles and downloads dependencies with no errors. May take a minute on first run.

**Step 4: Commit**

```bash
cd ..
git add tui/
git commit -m "feat: scaffold Rust TUI crate"
```

---

### Task 8: Implement `api.rs`

**Files:**
- Create: `tui/src/api.rs`
- Modify: `tui/src/main.rs`

**Step 1: Create `tui/src/api.rs`**

```rust
use serde::{Deserialize, Serialize};

const BASE_URL: &str = "http://127.0.0.1:9271";

#[derive(Debug, Clone, Deserialize)]
pub struct Speaker {
    pub name: String,
    pub alias: Option<String>,
    pub ip: String,
    pub volume: u8,
    pub muted: bool,
    pub state: String,
    pub group_coordinator: Option<String>,
    pub track: Option<Track>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Track {
    pub title: String,
    pub artist: String,
    pub album: String,
    pub duration: u64,
    pub position: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct Playlist {
    pub alias: String,
    pub favorite_name: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct PlayRequest {
    pub speaker: String,
    pub playlist: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct SpeakerRequest {
    pub speaker: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct VolumeRequest {
    pub speaker: String,
    pub volume: u8,
}

pub struct ApiClient {
    client: reqwest::Client,
    base_url: String,
}

impl ApiClient {
    pub fn new() -> Self {
        Self {
            client: reqwest::Client::new(),
            base_url: BASE_URL.to_string(),
        }
    }

    pub async fn get_speakers(&self) -> anyhow::Result<Vec<Speaker>> {
        let resp: serde_json::Value = self.client
            .get(format!("{}/speakers", self.base_url))
            .send().await?
            .json().await?;
        let speakers: Vec<Speaker> = serde_json::from_value(resp["speakers"].clone())?;
        Ok(speakers)
    }

    pub async fn get_playlists(&self) -> anyhow::Result<Vec<Playlist>> {
        let resp: serde_json::Value = self.client
            .get(format!("{}/playlists", self.base_url))
            .send().await?
            .json().await?;
        let map: std::collections::HashMap<String, String> =
            serde_json::from_value(resp["playlists"].clone())?;
        Ok(map.into_iter().map(|(alias, favorite_name)| {
            Playlist { alias, favorite_name }
        }).collect())
    }

    pub async fn play(&self, speaker: &str, playlist: &str) -> anyhow::Result<()> {
        self.client.post(format!("{}/play", self.base_url))
            .json(&PlayRequest {
                speaker: speaker.to_string(),
                playlist: playlist.to_string(),
            })
            .send().await?;
        Ok(())
    }

    pub async fn pause(&self, speaker: &str) -> anyhow::Result<()> {
        self.client.post(format!("{}/pause", self.base_url))
            .json(&SpeakerRequest { speaker: speaker.to_string() })
            .send().await?;
        Ok(())
    }

    pub async fn resume(&self, speaker: &str) -> anyhow::Result<()> {
        self.client.post(format!("{}/resume", self.base_url))
            .json(&SpeakerRequest { speaker: speaker.to_string() })
            .send().await?;
        Ok(())
    }

    pub async fn set_volume(&self, speaker: &str, volume: u8) -> anyhow::Result<()> {
        self.client.post(format!("{}/volume", self.base_url))
            .json(&VolumeRequest {
                speaker: speaker.to_string(),
                volume,
            })
            .send().await?;
        Ok(())
    }

    pub async fn next(&self, speaker: &str) -> anyhow::Result<()> {
        self.client.post(format!("{}/next", self.base_url))
            .json(&SpeakerRequest { speaker: speaker.to_string() })
            .send().await?;
        Ok(())
    }

    pub async fn previous(&self, speaker: &str) -> anyhow::Result<()> {
        self.client.post(format!("{}/previous", self.base_url))
            .json(&SpeakerRequest { speaker: speaker.to_string() })
            .send().await?;
        Ok(())
    }
}
```

**Step 2: Update `tui/src/main.rs` to declare the module**

```rust
mod api;

fn main() {
    println!("sonos-tui");
}
```

**Step 3: Compile to verify**

```bash
cd tui
cargo build
```

Expected: compiles with no errors.

**Step 4: Commit**

```bash
cd ..
git add tui/src/api.rs tui/src/main.rs
git commit -m "feat: implement ApiClient for daemon HTTP communication"
```

---

### Task 9: Implement `app.rs`

**Files:**
- Create: `tui/src/app.rs`
- Modify: `tui/src/main.rs`

**Step 1: Create `tui/src/app.rs`**

```rust
use crate::api::{Speaker, Playlist};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Panel {
    Speakers,
    Playlists,
    NowPlaying,
}

pub struct App {
    pub speakers: Vec<Speaker>,
    pub playlists: Vec<Playlist>,
    pub active_panel: Panel,
    pub speaker_index: usize,
    pub playlist_index: usize,
    pub should_quit: bool,
    pub status_message: Option<String>,
    pub last_refresh: std::time::Instant,
}

impl App {
    pub fn new() -> Self {
        Self {
            speakers: vec![],
            playlists: vec![],
            active_panel: Panel::Speakers,
            speaker_index: 0,
            playlist_index: 0,
            should_quit: false,
            status_message: None,
            last_refresh: std::time::Instant::now(),
        }
    }

    pub fn selected_speaker(&self) -> Option<&Speaker> {
        self.speakers.get(self.speaker_index)
    }

    pub fn selected_playlist(&self) -> Option<&Playlist> {
        self.playlists.get(self.playlist_index)
    }

    pub fn speaker_id(&self) -> Option<String> {
        self.selected_speaker().map(|s| {
            s.alias.clone().unwrap_or_else(|| s.name.clone())
        })
    }

    pub fn next_in_list(&mut self) {
        match self.active_panel {
            Panel::Speakers => {
                if !self.speakers.is_empty() {
                    self.speaker_index = (self.speaker_index + 1) % self.speakers.len();
                }
            }
            Panel::Playlists => {
                if !self.playlists.is_empty() {
                    self.playlist_index = (self.playlist_index + 1) % self.playlists.len();
                }
            }
            _ => {}
        }
    }

    pub fn prev_in_list(&mut self) {
        match self.active_panel {
            Panel::Speakers => {
                if !self.speakers.is_empty() {
                    self.speaker_index = self.speaker_index
                        .checked_sub(1)
                        .unwrap_or(self.speakers.len() - 1);
                }
            }
            Panel::Playlists => {
                if !self.playlists.is_empty() {
                    self.playlist_index = self.playlist_index
                        .checked_sub(1)
                        .unwrap_or(self.playlists.len() - 1);
                }
            }
            _ => {}
        }
    }

    pub fn cycle_panel(&mut self) {
        self.active_panel = match self.active_panel {
            Panel::Speakers => Panel::Playlists,
            Panel::Playlists => Panel::NowPlaying,
            Panel::NowPlaying => Panel::Speakers,
        };
    }
}
```

**Step 2: Update `tui/src/main.rs`**

```rust
mod api;
mod app;

fn main() {
    println!("sonos-tui");
}
```

**Step 3: Compile**

```bash
cd tui && cargo build
```

Expected: no errors.

**Step 4: Commit**

```bash
cd ..
git add tui/src/app.rs tui/src/main.rs
git commit -m "feat: implement App state management"
```

---

### Task 10: Implement `ui.rs`

**Files:**
- Create: `tui/src/ui.rs`
- Modify: `tui/src/main.rs`

**Step 1: Create `tui/src/ui.rs`**

```rust
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Gauge, List, ListItem, Paragraph},
    Frame,
};
use crate::app::{App, Panel};

const BG: Color = Color::Rgb(20, 20, 30);
const FG: Color = Color::Rgb(200, 200, 210);
const ACCENT: Color = Color::Rgb(130, 170, 255);
const PLAYING: Color = Color::Rgb(120, 220, 140);
const PAUSED: Color = Color::Rgb(240, 200, 80);
const DIM: Color = Color::Rgb(80, 80, 100);
const HIGHLIGHT_BG: Color = Color::Rgb(40, 45, 65);
const BORDER_ACTIVE: Color = ACCENT;
const BORDER_INACTIVE: Color = Color::Rgb(50, 50, 70);

pub fn draw(f: &mut Frame, app: &App) {
    let outer = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Min(1), Constraint::Length(3)])
        .split(f.area());

    let main = Layout::default()
        .direction(Direction::Horizontal)
        .constraints([Constraint::Percentage(45), Constraint::Percentage(55)])
        .split(outer[0]);

    let left = Layout::default()
        .direction(Direction::Vertical)
        .constraints([Constraint::Percentage(55), Constraint::Percentage(45)])
        .split(main[0]);

    draw_speakers(f, app, left[0]);
    draw_playlists(f, app, left[1]);
    draw_now_playing(f, app, main[1]);
    draw_help_bar(f, outer[1]);
}

fn panel_block(title: &str, active: bool) -> Block<'_> {
    let border_color = if active { BORDER_ACTIVE } else { BORDER_INACTIVE };
    Block::default()
        .title(format!(" {} ", title))
        .borders(Borders::ALL)
        .border_style(Style::default().fg(border_color))
        .style(Style::default().bg(BG))
}

fn draw_speakers(f: &mut Frame, app: &App, area: Rect) {
    let active = app.active_panel == Panel::Speakers;
    let block = panel_block("Speakers", active);

    let items: Vec<ListItem> = app.speakers.iter().enumerate().map(|(i, sp)| {
        let state_icon = match sp.state.as_str() {
            "PLAYING" => Span::styled("▶", Style::default().fg(PLAYING)),
            "PAUSED_PLAYBACK" => Span::styled("⏸", Style::default().fg(PAUSED)),
            _ => Span::styled("·", Style::default().fg(DIM)),
        };

        let display_name = sp.alias.as_deref().unwrap_or(&sp.name);
        let name_style = if i == app.speaker_index && active {
            Style::default().fg(ACCENT).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(FG)
        };

        let line = Line::from(vec![
            Span::raw(if i == app.speaker_index { " ► " } else { "   " }),
            Span::styled(format!("{:<16}", display_name), name_style),
            Span::styled(format!(" {:>3}", sp.volume), Style::default().fg(DIM)),
            Span::raw("  "),
            state_icon,
        ]);

        let mut item = ListItem::new(line);
        if i == app.speaker_index && active {
            item = item.style(Style::default().bg(HIGHLIGHT_BG));
        }
        item
    }).collect();

    let list = List::new(items).block(block);
    f.render_widget(list, area);
}

fn draw_playlists(f: &mut Frame, app: &App, area: Rect) {
    let active = app.active_panel == Panel::Playlists;
    let block = panel_block("Playlists", active);

    let items: Vec<ListItem> = app.playlists.iter().enumerate().map(|(i, pl)| {
        let style = if i == app.playlist_index && active {
            Style::default().fg(ACCENT).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(FG)
        };

        let line = Line::from(vec![
            Span::raw(if i == app.playlist_index { " ► " } else { "   " }),
            Span::styled(format!("{:<10}", pl.alias), style),
            Span::styled(
                truncate(&pl.favorite_name, 24),
                Style::default().fg(DIM),
            ),
        ]);

        let mut item = ListItem::new(line);
        if i == app.playlist_index && active {
            item = item.style(Style::default().bg(HIGHLIGHT_BG));
        }
        item
    }).collect();

    let list = List::new(items).block(block);
    f.render_widget(list, area);
}

fn draw_now_playing(f: &mut Frame, app: &App, area: Rect) {
    let active = app.active_panel == Panel::NowPlaying;
    let block = panel_block("Now Playing", active);
    let inner = block.inner(area);
    f.render_widget(block, area);

    let speaker = app.selected_speaker();

    if let Some(sp) = speaker {
        if let Some(track) = &sp.track {
            let chunks = Layout::default()
                .direction(Direction::Vertical)
                .constraints([
                    Constraint::Length(1),
                    Constraint::Length(1),
                    Constraint::Length(1),
                    Constraint::Length(1),
                    Constraint::Length(2),
                    Constraint::Length(1),
                    Constraint::Length(1),
                    Constraint::Length(2),
                    Constraint::Length(1),
                    Constraint::Min(0),
                ])
                .split(inner);

            let title = Paragraph::new(Line::from(vec![
                Span::styled("  ♫ ", Style::default().fg(PLAYING)),
                Span::styled(
                    &track.title,
                    Style::default().fg(FG).add_modifier(Modifier::BOLD),
                ),
            ]));
            f.render_widget(title, chunks[1]);

            let artist = Paragraph::new(Line::from(vec![
                Span::raw("    "),
                Span::styled(&track.artist, Style::default().fg(ACCENT)),
            ]));
            f.render_widget(artist, chunks[2]);

            let album = Paragraph::new(Line::from(vec![
                Span::raw("    "),
                Span::styled(&track.album, Style::default().fg(DIM)),
            ]));
            f.render_widget(album, chunks[3]);

            let ratio = if track.duration > 0 {
                track.position as f64 / track.duration as f64
            } else {
                0.0
            };
            let gauge = Gauge::default()
                .gauge_style(Style::default().fg(ACCENT).bg(Color::Rgb(40, 40, 55)))
                .ratio(ratio)
                .label("");
            let gauge_area = Rect {
                x: chunks[5].x + 4,
                width: chunks[5].width.saturating_sub(8),
                ..chunks[5]
            };
            f.render_widget(gauge, gauge_area);

            let time_str = format!(
                "    {}  /  {}",
                format_time(track.position),
                format_time(track.duration),
            );
            let time = Paragraph::new(Span::styled(time_str, Style::default().fg(DIM)));
            f.render_widget(time, chunks[6]);

            let vol_ratio = sp.volume as f64 / 100.0;
            let vol_gauge = Gauge::default()
                .gauge_style(Style::default().fg(PLAYING).bg(Color::Rgb(40, 40, 55)))
                .ratio(vol_ratio)
                .label(format!("Vol: {}", sp.volume));
            let vol_area = Rect {
                x: chunks[8].x + 4,
                width: chunks[8].width.saturating_sub(8),
                ..chunks[8]
            };
            f.render_widget(vol_gauge, vol_area);

            return;
        }
    }

    let idle = Paragraph::new(vec![
        Line::from(""),
        Line::from(Span::styled(
            "  Nothing playing",
            Style::default().fg(DIM),
        )),
    ]);
    f.render_widget(idle, inner);
}

fn draw_help_bar(f: &mut Frame, area: Rect) {
    let help = Line::from(vec![
        Span::styled(" Tab", Style::default().fg(ACCENT)),
        Span::styled(" panel  ", Style::default().fg(DIM)),
        Span::styled("↑↓", Style::default().fg(ACCENT)),
        Span::styled(" nav  ", Style::default().fg(DIM)),
        Span::styled("Enter", Style::default().fg(ACCENT)),
        Span::styled(" play  ", Style::default().fg(DIM)),
        Span::styled("Space", Style::default().fg(ACCENT)),
        Span::styled(" pause  ", Style::default().fg(DIM)),
        Span::styled("+/-", Style::default().fg(ACCENT)),
        Span::styled(" vol  ", Style::default().fg(DIM)),
        Span::styled("n/p", Style::default().fg(ACCENT)),
        Span::styled(" track  ", Style::default().fg(DIM)),
        Span::styled("q", Style::default().fg(ACCENT)),
        Span::styled(" quit", Style::default().fg(DIM)),
    ]);

    let block = Block::default()
        .borders(Borders::ALL)
        .border_style(Style::default().fg(BORDER_INACTIVE))
        .style(Style::default().bg(BG));
    let paragraph = Paragraph::new(help).block(block);
    f.render_widget(paragraph, area);
}

fn format_time(seconds: u64) -> String {
    format!("{}:{:02}", seconds / 60, seconds % 60)
}

fn truncate(s: &str, max: usize) -> String {
    if s.len() > max {
        format!("{}…", &s[..max - 1])
    } else {
        s.to_string()
    }
}
```

**Step 2: Update `tui/src/main.rs`**

```rust
mod api;
mod app;
mod ui;

fn main() {
    println!("sonos-tui");
}
```

**Step 3: Compile**

```bash
cd tui && cargo build
```

Expected: no errors.

**Step 4: Commit**

```bash
cd ..
git add tui/src/ui.rs tui/src/main.rs
git commit -m "feat: implement Ratatui UI layout and rendering"
```

---

### Task 11: Implement `main.rs` event loop

**Files:**
- Modify: `tui/src/main.rs`

**Step 1: Replace `tui/src/main.rs` with full implementation**

```rust
mod api;
mod app;
mod ui;

use std::time::Duration;
use anyhow::Result;
use crossterm::{
    event::{self, Event, KeyCode, KeyEvent},
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    execute,
};
use ratatui::prelude::*;
use crate::api::ApiClient;
use crate::app::App;

const POLL_INTERVAL: Duration = Duration::from_secs(2);
const TICK_RATE: Duration = Duration::from_millis(100);

#[tokio::main]
async fn main() -> Result<()> {
    enable_raw_mode()?;
    let mut stdout = std::io::stdout();
    execute!(stdout, EnterAlternateScreen)?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let result = run(&mut terminal).await;

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;

    result
}

async fn run(terminal: &mut Terminal<CrosstermBackend<std::io::Stdout>>) -> Result<()> {
    let client = ApiClient::new();
    let mut app = App::new();

    if let Ok(speakers) = client.get_speakers().await {
        app.speakers = speakers;
    }
    if let Ok(playlists) = client.get_playlists().await {
        app.playlists = playlists;
    }

    loop {
        terminal.draw(|f| ui::draw(f, &app))?;

        if event::poll(TICK_RATE)? {
            if let Event::Key(key) = event::read()? {
                handle_key(&mut app, &client, key).await?;
            }
        }

        if app.last_refresh.elapsed() >= POLL_INTERVAL {
            if let Ok(speakers) = client.get_speakers().await {
                app.speakers = speakers;
            }
            app.last_refresh = std::time::Instant::now();
        }

        if app.should_quit {
            break;
        }
    }

    Ok(())
}

async fn handle_key(app: &mut App, client: &ApiClient, key: KeyEvent) -> Result<()> {
    match key.code {
        KeyCode::Char('q') => app.should_quit = true,
        KeyCode::Tab => app.cycle_panel(),

        KeyCode::Up | KeyCode::Char('k') => app.prev_in_list(),
        KeyCode::Down | KeyCode::Char('j') => app.next_in_list(),

        KeyCode::Enter => {
            if let (Some(speaker_id), Some(playlist)) =
                (app.speaker_id(), app.selected_playlist())
            {
                let _ = client.play(&speaker_id, &playlist.alias).await;
                app.status_message = Some(format!(
                    "Playing {} on {}", playlist.alias, speaker_id
                ));
            }
        }

        KeyCode::Char(' ') => {
            if let Some(sp) = app.selected_speaker() {
                let id = sp.alias.as_deref().unwrap_or(&sp.name);
                match sp.state.as_str() {
                    "PLAYING" => { let _ = client.pause(id).await; }
                    _ => { let _ = client.resume(id).await; }
                }
            }
        }

        KeyCode::Char('+') | KeyCode::Char('=') => {
            if let Some(sp) = app.selected_speaker() {
                let id = sp.alias.as_deref().unwrap_or(&sp.name).to_string();
                let new_vol = (sp.volume + 5).min(100);
                let _ = client.set_volume(&id, new_vol).await;
            }
        }
        KeyCode::Char('-') => {
            if let Some(sp) = app.selected_speaker() {
                let id = sp.alias.as_deref().unwrap_or(&sp.name).to_string();
                let new_vol = sp.volume.saturating_sub(5);
                let _ = client.set_volume(&id, new_vol).await;
            }
        }

        KeyCode::Char('n') => {
            if let Some(id) = app.speaker_id() {
                let _ = client.next(&id).await;
            }
        }
        KeyCode::Char('p') => {
            if let Some(id) = app.speaker_id() {
                let _ = client.previous(&id).await;
            }
        }

        _ => {}
    }
    Ok(())
}
```

**Step 2: Build release binary**

```bash
cd tui
cargo build --release
```

Expected: compiles cleanly. Binary at `tui/target/release/sonos-tui`.

**Step 3: Run against live daemon**

Start daemon in one terminal:
```bash
cd daemon && source .venv/bin/activate && sonosd
```

Run TUI in another:
```bash
./tui/target/release/sonos-tui
```

Expected: three-panel TUI showing cthulhu in the speakers list, "altwave" in playlists. Press `Enter` to play, `Space` to pause, `q` to quit.

**Step 4: Commit**

```bash
git add tui/src/main.rs
git commit -m "feat: implement event loop and keybindings — TUI complete"
```

---

## Done

Both processes are implemented. The system is fully functional against your real Sonos speaker.
